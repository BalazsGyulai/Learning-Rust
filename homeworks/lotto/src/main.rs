use rand::Rng;
use std::io::stdin;

/// N is how many different numbers should the user give.
const N: u64 = 6;
/// RANGE_MIN is the bottom of the range in which the numbers, that the user give, should be in.
const RANGE_MIN: i64 = 1;
/// RANGE_MAX is the top of the range in which the numbers, that the user give, should be in.
const RANGE_MAX: i64 = 45;

fn main() {
    // Holds the name of the game. Important when printing the welcome text.
    let game_name: &str = "LOTTO";
    // Since this is the longest text in the header, we save it so we can use its length to position the game name to the center.
    let my_text: &str = &format!("Please pick {N} different numbers from the range {RANGE_MIN}-{RANGE_MAX}.");
    let my_text_len: usize = my_text.len();

    // HEADER / WELCOME TEXT
    println!("-------------------------------------------------------------------------");
    println!("{:^my_text_len$}", game_name); // centering the game name, won't be perfectly aligned because I didn't considered the lengths of the game settings.
    println!("-------------------------------------------------------------------------");
    // printing essential informations for the user.
    println!("{my_text}");
    println!("You can separate them with any kind of character or space.\n");

    // Read input from user.
    let mut input = String::new();
    let stdin = stdin();
    stdin.read_line(&mut input).unwrap();

    // For debug purposes
    // println!("Your input was: {input}");

    // Converting the input to a bytes vector.
    let mut input: Vec<u8> = string_to_vector(input);

    // For debug purposes
    // println!("All {:?}", input);

    // Removes any unecessery characters
    remove_extra_characters(&mut input);

    // For debug purposes
    // println!("Without extra characters {:?}", input);

    // We will convert the input back into integers and store it inside a new input.
    let mut input: Vec<i64> = convert_input_back(&mut input);

    // For depug purposes
    // println!("Cleared input {:?}", input);

    // we store it because we use it twice (not necessary to store it but its clearer to understand the if after it).
    let input_length: u64 = input.len() as u64;

    // ERROR MESSAGES
    if input_length != N {
        // When there is more number given then it should be we check wether its more or less, and we give an error message back based on this information
        if input_length > N {
            println!("Please check your numbers! Give only {N} numbers!");
        } else {
            println!("Please check your numbers! Give {N} numbers!");
        }
    } else if is_number_out_of_range(&input) { // checks if there is a number in the input that is not within the given range.
        println!(
            "Please check your numbers! Every number should be within the range of {RANGE_MIN} and {RANGE_MAX}"
        );
    } else if is_numbers_distinct(&input) { // checks whether there is two or more numbers that are the same.
        println!("Please check your numbers! Every number should be unique.");
    } else {
        arrange_array_in_ascend(&mut input); // arranges an array in ascending order

        // For debug purposes
        // print_user_input(&input);
        // println!("You input was: {:?}", input);

        // stores the numbers that are generated by the computer
        let computer_generated_numbers: Vec<i64> = {
            let mut array: Vec<i64> = Vec::new();

            // Generates N different number
            for _ in 0..N {
                array.push(generate_unique_number(&array, RANGE_MIN, RANGE_MAX)); // only pushes the number when its unique
            }

            arrange_array_in_ascend(&mut array);

            array
        };

        // generates a unique bonus number that is not exist inside the computer_generated_numbers, runs until it finds an unique number
        let bonus_number: i64 = generate_unique_number(
            &computer_generated_numbers,
            RANGE_MIN,
            RANGE_MAX
        );

        // prints the user input and the computer generated numbers very beautifully
        print_user_input(&input, &computer_generated_numbers, &bonus_number);

        // For debug purposes
        // let computer_generated_numbers: Vec<i64> = vec![1,2,3,4,5,6];
        // let bonus_number: i64 = 7;
        // println!("Generated {:?}", computer_generated_numbers);
        // println!("Bonus {:?}", bonus_number);

        // Evaluates the prize based on how many numbers are the same whithin the user input and computer generated numbers.
        determining_rank(&input, &computer_generated_numbers, &bonus_number);
    }
}

// ----------------------------------------------
// GAME LOGIC / GAME FUNCTIONS BELOW
// ----------------------------------------------

/** 
Converts a string into a Vector in which each element is character from the string represented as a u8 value. 
E.g. From String "12" it will create a Vector that contains [49, 50] and the function will return this Vector
*/
fn string_to_vector(input: String) -> Vec<u8> {
    // input_in_bytes stores an array &[u8]
    let input_in_bytes = input.as_bytes();
    // my_vector will be our vector in which we copy the elements of input_in_bytes.
    let mut my_vector: Vec<u8> = Vec::with_capacity(input_in_bytes.len());

    for i in 0..input_in_bytes.len() {
        my_vector.push(input_in_bytes[i] as u8);
    }

    my_vector
}

/** 
Gets a vector as an argument. Since we don't care about the characters that are not numbers, we will make every unecessary character into a space that is 32 in the ASCII table. After we did this, we will remove any duplicate spaces.
*/
fn remove_extra_characters(vector: &mut Vec<u8>) {
    /*! This function changes the unecessary characters into spaces that are represented as '32' in the ASCII table. */
    change_character_to_space(vector);

    let mut i: u64 = 0;

    /* 
    This part removes the extra spaces in a way so only one space will be stay behind. This is necessary because we will use the spaces 
    to know where a new digit starts or ends.
    */
    while i < (vector.len() as u64) - 1 {
        if vector[i as usize] == 32 && vector[(i + 1) as usize] == 32 {
            // custom_remove is a function that removes the i element from an array.
            *vector = custom_remove(vector, (i + 1) as usize);
        } else {
            i += 1;
        }
    }

    // In case there is an extra space in the front it will remove it from the front of the array
    if vector[0] == 32 {
        *vector = custom_remove(vector, 0);
    }
}

/// Changes every character into a space represented as '32' in the ASCII table. We know that 0 -> 48 and 9 -> 57, every other number is not important for us
fn change_character_to_space(vector: &mut Vec<u8>) {
    for i in 0..vector.len() as usize {
        if vector[i as usize] < 48 || vector[i as usize] > 57 {
            vector[i as usize] = 32;
        }
    }
}

/// Removes the i element of a given array, then it returns the new array.
fn custom_remove(array: &Vec<u8>, i: usize) -> Vec<u8> {
    // we declare a Vector that has the capacity of holding all the elements of the given array minus one element becuase we will remove one.
    let mut new_array: Vec<u8> = Vec::with_capacity(array.len() - 1);

    for y in 0..array.len() {
        // we add every element to the new_array but the element at the index of i
        if (y as usize) != i {
            new_array.push(array[y as usize]);
        }
    }

    new_array
}

/** 
Gets an argument (input) that is in bytes. It will search for the first space (32), will store where it is then will convert back the bytes back into integers and repeats this process on the whole array. Finally, will return the array that holds the integers.
*/
fn convert_input_back(input: &mut Vec<u8>) -> Vec<i64> {
    // we will store here the integers that are converted back.
    let mut new_vector: Vec<i64> = Vec::new();
    // stores where the array was cut the last time.
    let mut cut_front: u64 = 0;

    for i in 0..input.len() {
        // goes until finds a space
        if input[i as usize] == 32 {
            // adds the integer that is converted back
            // cut_front -> the last place the array was cut, default is 0
            // i -> place until it needs to be cut (it is not counted in when cutting it)
            // input -> the array which we work on
            new_vector.push(get_value_back(cut_front, i as u64, input));

            // stores the place where the array was cut. (i + 1) because we don't need to convert back the space.
            if i + 1 < input.len() {
                cut_front = (i + 1) as u64;
            }
        }
    }

    new_vector
}

/// Converts a particular part of an array back to integers.
fn get_value_back(start: u64, end: u64, array: &Vec<u8>) -> i64 {
    // stores the integer
    let mut sum: i64 = 0;

    // sees only a particular part of the array
    for i in start..end {
        // we make a multiply variable that hold 1, 10, 100, ..., this is that knows where the number takes place.
        // E.g:
        // We have the number 123 it can be represented as
        // 1 * 100 + 2 * 10 + 3 * 1
        let multiply: i64 = {
            let mut number: i64 = 1;

            for _ in i..end - 1 {
                number *= 10;
            }

            number
        };

        // custom parse gets a byte number and gets back an i64 number, then we multiply it so we get back the origin number
        sum += custom_parse(array[i as usize]) * multiply;
    }

    sum
}

/// Gets a byte number then returns an integer
// Note: this is needed because if you converted a 48u8 number to i64 it would still be 48 but in i64 format, that is why match the byte like 48 that is 0 in ASCII, so we return 0
fn custom_parse(character: u8) -> i64 {
    match character {
        48u8 => 0,
        49u8 => 1,
        50u8 => 2,
        51u8 => 3,
        52u8 => 4,
        53u8 => 5,
        54u8 => 6,
        55u8 => 7,
        56u8 => 8,
        _ => 9,
    }
}

/// Gets an array filled with numbers and checks whether an element is out of range. Returns true in case there is a number out of range, false in case all the numbers are in range.
fn is_number_out_of_range(array: &Vec<i64>) -> bool {
    let mut number_out_of_range: bool = false;
    let mut i: u64 = 0;

    // runs until it finds a number that is out of range or reaches the end of the array.
    // NOTE: you could have use a for cycle instead of while, but using while in this case increase the performance. Also if you are using an if, be careful not to change back the number_out_of_range to false, when there is number within range.
    while i < (array.len() as u64) && !number_out_of_range {
        if array[i as usize] < RANGE_MIN || array[i as usize] > RANGE_MAX {
            number_out_of_range = true;
        }

        i += 1;
    }

    number_out_of_range
}

/// Gets an array filled with numbers and checks whether all the numbers are distinct. Returns true in case the numbers are unique, false in case there are a number that is in more than once.
fn is_numbers_distinct(array: &Vec<i64>) -> bool {
    let mut same_numbers: bool = false;
    let mut i: u64 = 0;
    let mut y: u64 = 1;

    // NOTE: you could use a for cycle here as well, just watch out how you write it.
    while i < (array.len() as u64) && !same_numbers { // gets a number...
        while y < (array.len() as u64) && !same_numbers { // ...and compares it with all the other numbers, that are behind it, inside the array
            if array[i as usize] == array[y as usize] {
                same_numbers = true;
            }

            y += 1;
        }

        i += 1;
    }

    same_numbers
}

/// Gets an array and arranges its elements in ascending order
fn arrange_array_in_ascend(array: &mut Vec<i64>) {
    for i in 0..array.len() {
        for y in i..array.len() {
            if array[i as usize] > array[y as usize] {
                let temp: i64 = array[y as usize];
                array[y as usize] = array[i as usize];
                array[i as usize] = temp;
            }
        }
    }
}

/// Generates a unique number
// NOTE: since we declared the RANGE_MIN and RANGE_MAX it is not necessary to pass them as argumets, you can use them inside the function instead
fn generate_unique_number(array: &Vec<i64>, start: i64, end: i64) -> i64 {
    let mut generator = rand::rng();
    let mut number: i64 = generator.random_range(start..=end); // picks a number

    // runs until the generated number is not inside the array (since the user cannot pick the same numbers, the computer shouldn't)
    while is_element_in_array(number, &array) { // checks whether the generated number is inside the array given as the argument of the funtion
        number = generator.random_range(start..=end); // picks a number
        // HERE: instead of start and end you can use directly RANGE_MIN and RANGE_MAX, this way you don't need them as arguments
    }

    number
}

/// Gets an element and an array. Checks whether the element exits inside the array. Returs true if the element exits, false if the element is not exist inside the array
fn is_element_in_array(element: i64, array: &Vec<i64>) -> bool {
    let mut found: bool = false;
    let mut i: u64 = 0;

    // runs until the element is found whithin the array, or the i (index) is reaches the end of the array
    while i < (array.len() as u64) && !found {
        if array[i as usize] == element {
            found = true;
        }

        i += 1;
    }

    found
}

/// Needed to format the text nicely. This is just extra shit that takes time :)
fn print_user_input(input: &Vec<i64>, computer_generated_numbers: &Vec<i64>, bonus_number: &i64) {
    let user_numbers: String = array_to_string(input); // user input into string
    let mut lotto_numbers: String = array_to_string(computer_generated_numbers); // computer numbers into string
    lotto_numbers.push_str(&format!(" | {}", bonus_number) as &str); // adds the bonus number to the end of the computer numbers separated by |

    let text_static: &str = "Your input was:";
    let lotto_text_static: &str = "Lotto numbers were:";

    let lotto_numbers_length: usize = lotto_numbers.len(); // string that hold the numbers that are generated by the computer will be always longer since it has an extra number, but it won't if you change the settings in a way you can select a number like 90000 and the computer only chooses one digit numbers. But now I don't care.
    let lotto_text_length: usize = lotto_text_static.len(); // Now this text will definetly will be longer, unless you change it to something else

    let mut text: String = format!("{:<lotto_text_length$}", text_static); // we store the "printed" text so we can show it along the numbers
    println!("{}\t{:<lotto_numbers_length$}", text, user_numbers); // this connects the idea of printing the two text nicely

    // same thins apply here. We apply the lotto_numbers_length, so if we would align the text differently it will calculate with same number
    text = format!("{:<lotto_text_length$}", lotto_text_static);
    println!("{}\t{:<lotto_numbers_length$}", text, lotto_numbers);
}

/// Gets an array and returns a String that holds all the number separted by comas
fn array_to_string(array: &Vec<i64>) -> String {
    let mut numbers: String = "".to_string();

    for i in 0..array.len() - 1 {
        numbers.push_str(&array[i as usize].to_string());
        numbers.push_str(", ");
    }

    // manually pushing the last item, so we don't need an extra if inside the for cycle
    numbers.push_str(&array[array.len() - 1].to_string());

    numbers
}

/// Handles checking how many numbers are the same from the user input inside the numbers generated by the computer
fn determining_rank(input: &Vec<i64>, computer_generated_numbers: &Vec<i64>, bonus_number: &i64) {
    let mut normal_match: u64 = 0; // counter of the same numbers
    let mut bonus_match: bool = false; // will be true when a user number is the same as the bonus number

    // checks all the numbers of the user 
    for i in 0..input.len() {
        let mut found_match: bool = false; // has to reset everytime since we compare a new number with the elements of the computer
        let mut y = 0; // has to reset because we will start comparing the first element of the computer

        // runs until it finds numbers that are the same, or reaches the end of the array of the computer
        while y < computer_generated_numbers.len() && !found_match {
            if input[i as usize] == computer_generated_numbers[y as usize] {
                normal_match += 1;
                found_match = true;
            }

            y += 1;
        }

        // also compares the user element with the bonus number
        if !bonus_match && input[i as usize] == *bonus_number {
            bonus_match = true;
        }
    }

    // this is the part that is the table from the task description
    match (normal_match, bonus_match) {
        (6, false) => print_prize_and_correct_guess(1, normal_match),
        (5, true) => print_prize_and_correct_guess(2, normal_match),
        (5, false) => print_prize_and_correct_guess(3, normal_match),
        (4, true) => print_prize_and_correct_guess(4, normal_match),
        (4, false) => print_prize_and_correct_guess(5, normal_match),
        (3, true) => print_prize_and_correct_guess(6, normal_match),
        (3, false) => print_prize_and_correct_guess(7, normal_match),
        _ => print_prize_and_correct_guess(8, normal_match),
    }
}

/// Prints the addictive gambling text at the end of the game
fn print_prize_and_correct_guess(prize: u8, guess: u64) {
    if prize != 8 {
        println!("\nCongratulation!");
        println!("Your price is {prize}.");
        println!("You guessed {guess} number correctly!");
    } else {
        println!("\nI'm sorry this time you didn't win! Next time you'll have more luck!");
        println!("Your price is {prize}.");
        println!("You guessed {guess} number correctly!");
    }
}




